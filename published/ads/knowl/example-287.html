<!DOCTYPE html>
<html lang="en-US">
<!--********************************************-->
<!--*       Generated from PreTeXt source      *-->
<!--*                                          *-->
<!--*         https://pretextbook.org          *-->
<!--*                                          *-->
<!--********************************************-->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="robots" content="noindex, nofollow">
</head>
<body class="ignore-math">
<article class="example example-like"><h4 class="heading">
<span class="type">Example</span><span class="space"> </span><span class="codenumber">15.5.7</span><span class="period">.</span><span class="space"> </span><span class="title">A Somewhat More Efficient Linear Code.</span>
</h4>
<div class="para">The encoding that we will consider here takes a block <span class="process-math">\(a = \left(a_1, a_2, a_3 \right)\)</span> and produces a code word of length 6. As in the triple repetition code, each code word will differ from each other code word by at least three bits. As a result, any single error will not push a code word close enough to another code word to cause confusion. Now for the details.</div> <div class="para logical">
<div class="para">Let</div>
<div class="displaymath process-math">
\begin{equation*}
G=\left(
\begin{array}{cccccc}
1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 \\
0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 1 \\
\end{array}
\right).
\end{equation*}
</div>
<div class="para">We call <span class="process-math">\(G\)</span> the <dfn class="terminology">generator matrix</dfn>  for the code, and let <span class="process-math">\(a = \left(a_1, a_2, a_3 \right)\)</span> be our message. Define <span class="process-math">\(e : \mathbb{Z}_2{}^3 \to \mathbb{Z}_2{}^6\)</span> by</div>
<div class="displaymath process-math">
\begin{equation*}
e(a) = a G = \left(a_1, a_2, a_3,a_4, a_5, a_6\right)
\end{equation*}
</div>
<div class="para">where</div>
<div class="displaymath process-math">
\begin{equation*}
\begin{array}{r@{}r@{}r@{}r@{}r@{}r@{}r@{}}
a_4  &amp;= &amp; a_1 &amp;  {}+_2{}     &amp;  a_2  &amp;       &amp;        \\
a_5  &amp;= &amp; a_1 &amp;              &amp;       &amp;{}+_2{}  &amp; a_3  \\
a_6  &amp;= &amp;  &amp;              &amp;  a_2   &amp;{}+_2{}  &amp; a_3  \\
\end{array}
\end{equation*}
</div>
</div>  <div class="para logical">
<div class="para">Notice that since matrix multiplication is distributive over addition, we have</div>
<div class="displaymath process-math">
\begin{equation*}
e(a + b)= (a+b)G = aG + bG = e(a)+e(b)
\end{equation*}
</div>
<div class="para">for all <span class="process-math">\(a, b \in \mathbb{Z}_2{}^3\text{.}\)</span> This equality, may look familiar from the definition of an isomorphism, but in this case the function <span class="process-math">\(e\)</span> is not onto.  If you’ve read about homomorphisms, this is indeed an example of one.</div>
</div> <div class="para logical">
<div class="para">One way to see that any two distinct code words have a distance from one another of at least 3 is to consider the images of any two distinct messages.  If <span class="process-math">\(a\)</span> and <span class="process-math">\(b\)</span> are distinct elements of <span class="process-math">\(\mathbb{Z}_2{}^3\text{,}\)</span> then <span class="process-math">\(c = a + b\)</span> has at least one coordinate equal to 1. Now consider the difference between <span class="process-math">\(e(a)\)</span> and <span class="process-math">\(e(b)\text{:}\)</span>
</div>
<div class="displaymath process-math">
\begin{equation*}
\begin{split}
e(a) + e(b) &amp;= e(a + b) \\
&amp; = e(c)\\
\end{split}
\end{equation*}
</div>
<div class="para">Whether <span class="process-math">\(c\)</span> has 1, 2, or 3 ones, <span class="process-math">\(e(c)\)</span> must have at least three ones.  This can be seen by considering the three cases separately.  For example, if <span class="process-math">\(c\)</span> has a single one, two of the parity bits are also 1.  Therefore, <span class="process-math">\(e(a)\)</span> and <span class="process-math">\(e(b)\)</span> differ in at least three bits. By the same logic as with triple repetition, a single bit error in any code word produces an element of the code space that is contained in on of the balls of radius 1 centered about a code word.</div>
</div> <div class="para logical">
<div class="para">Now consider the problem of decoding received transmissions. Imagine that a code word, <span class="process-math">\(e(a)\text{,}\)</span> is transmitted, and <span class="process-math">\(b= \left(b_1, b_2, b_3,b_4, b_5, b_6\right)\)</span> is received. At the receiving end, we know the formula for <span class="process-math">\(e(a)\text{,}\)</span> and if no error has occurred in transmission,</div>
<div class="displaymath process-math">
\begin{equation*}
\begin{array}{c}
b_1= a_1 \\
b_2=a_2 \\
b_3=a_3 \\
b_4=a_1+_2a_2 \\
b_5=a_1+_2a_3 \\
b_6=a_2+_2a_3 \\
\end{array}
\Rightarrow 
\begin{array}{r@{}r@{}r@{}r@{}r@{}r@{}r@{}r@{}r@{}r@{}r@{}r@{}}
b_1 &amp; +_2 &amp; b_2 &amp;      &amp;   &amp;+_2&amp; b_4&amp;    &amp;     &amp;    &amp;   &amp;=0\\
b_1 &amp;     &amp;     &amp; +_2  &amp;b_3&amp;   &amp;    &amp; +_2&amp; b_5 &amp;    &amp;   &amp;=0\\
&amp;     &amp; b_2 &amp; +_2  &amp;b_3&amp;   &amp;    &amp;    &amp;     &amp;+_2 &amp;b_6&amp;=0\\
\end{array}
\end{equation*}
</div>
<div class="para">The three equations on the right are called parity-check equations. If any of them are not true, an error has occurred. This error checking can be described in matrix form.</div>
</div> <div class="para logical">
<div class="para">Let</div>
<div class="displaymath process-math">
\begin{equation*}
H=\left(
\begin{array}{ccc}
1 &amp; 1 &amp; 0 \\
1 &amp; 0 &amp; 1 \\
0 &amp; 1 &amp; 1 \\
1 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 1 \\
\end{array}
\right)
\end{equation*}
</div>
</div> <div class="para">The matrix <span class="process-math">\(H\)</span> is called the parity-check matrix for this code. Now define <span class="process-math">\(p:\mathbb{Z}_2{}^6 \to \mathbb{Z}_2{}^3\)</span> by <span class="process-math">\(p(b) = b H\text{.}\)</span>  We call <span class="process-math">\(p(b)\)</span> the <dfn class="terminology">syndrome</dfn> of the received block. For example, <span class="process-math">\(p(0,1,0,1,0,1)=(0,0,0)\)</span>  and   <span class="process-math">\(p(1,1,1,1,0,0)=(1,0,0)\)</span>
</div> <div class="para">Note that <span class="process-math">\(p\)</span> has a similar property as <span class="process-math">\(e\text{,}\)</span> that <span class="process-math">\(p(b_1+b_2)=p(b_1)+p(b_2)\text{.}\)</span> If the syndrome of a block is <span class="process-math">\((0, 0, 0)\text{,}\)</span> we can be almost certain that the message block is <span class="process-math">\(\left(b_1, b_2, b_3\right)\text{.}\)</span>
</div> <div class="para logical">
<div class="para">Next we turn to the method of correcting errors. Despite the fact that there are only eight code words, one for each three-bit block value, the set of possible received blocks is <span class="process-math">\(\mathbb{Z}_2{}^6\text{,}\)</span> with 64 elements. Suppose that <span class="process-math">\(b\)</span> is not a code word, but that it differs from a code word by exactly one bit. In other words, it is the result of a single error in transmission. Suppose that <span class="process-math">\(w\)</span> is the code word that <span class="process-math">\(b\)</span> is closest to and that they differ in the first bit. Then <span class="process-math">\(b + w = (1, 0, 0, 0, 0, 0)\)</span> and</div>
<div class="displaymath process-math">
\begin{equation*}
\begin{split}
p(b) &amp; = p(b) + p(w)\quad \textrm{  since }p(w) = (0, 0, 0)\\
&amp;=b H + w H \\
&amp;=(b+w)H\quad \textrm{ by the distributive property}\\
&amp;=p(b+w)\\
&amp; =p(1,0,0,0,0,0)\\
&amp; =(1,1,0)\\
\end{split}
\end{equation*}
</div>
<div class="para">This is the first row of <span class="process-math">\(H\text{!}\)</span>
</div>
</div> <div class="para">Note that we haven’t specified <span class="process-math">\(b\)</span> or <span class="process-math">\(w\text{,}\)</span> only that they differ in the first bit. Therefore, if <span class="process-math">\(b\)</span> is received, there was probably an error in the first bit and <span class="process-math">\(p(b)= (1, 1, 0)\text{,}\)</span> the transmitted code word was probably <span class="process-math">\(b + (1, 0, 0, 0, 0, 0)\)</span> and the message block was <span class="process-math">\(\left(b_1+_2 1, b_2, b_3\right)\text{.}\)</span> The same analysis can be done if <span class="process-math">\(b\)</span> and <span class="process-math">\(w\)</span> differ in any of the other five bits.</div> <div class="para">In general, if the syndrome of a received string of bits is the <span class="process-math">\(k\)</span>th row of the parity check matrix, the error has occurred in the <span class="process-math">\(k\)</span>th bit.</div> </article><span class="incontext"><a href="s-coding-theory-groups.html#example-287" class="internal">in-context</a></span>
</body>
</html>
